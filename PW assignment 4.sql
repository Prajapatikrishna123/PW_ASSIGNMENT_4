-- Q1  Write a query using a CTE to retrieve the distinct list of actor names and the number of films they have
-- acted in from the actor and film_actor tables.
WITH ActorFilmCount AS (
    SELECT
        a.actor_id,
        a.first_name,
        COUNT(fa.film_id) AS film_count
    FROM
        actor a
    JOIN
        film_actor fa ON a.actor_id = fa.actor_id
    GROUP BY
        a.actor_id,
        a.first_name
)
SELECT
    first_name,
    film_count
FROM
    ActorFilmCount
ORDER BY
    first_name;
    
-- Q2. RecuVsive CTE Use a recursive CTE to generate a hierarchical list of categories and their subcategories from the
-- category table in Sakila.alter
WITH RECURSIVE CategoryHierarchy AS (
    -- Anchor member: Select the root categories (categories with no parent)
    SELECT
        category_id,
        name,
        parent_category_id,
        name AS hierarchy_path,
        1 AS level
    FROM
        hierarchical_category
    WHERE
        parent_category_id IS NULL

    UNION ALL

    -- Recursive member: Select subcategories and build the hierarchy path
    SELECT
        c.category_id,
        c.name,
        c.parent_category_id,
        CONCAT(ch.hierarchy_path, ' > ', c.name) AS hierarchy_path,
        ch.level + 1 AS level
    FROM
        hierarchical_category c
    INNER JOIN
        CategoryHierarchy ch ON c.parent_category_id = ch.category_id
)

-- Final query to select from the recursive CTE
SELECT
    category_id,
    name,
    parent_category_id,
    hierarchy_path,
    level
FROM
    CategoryHierarchy
ORDER BY
    hierarchy_path;

-- Q3. CTE with Joins
-- Create a CTE that combines information from film the language and tables to display the film title, language
-- name, and rental rate
WITH FilmLanguageInfo AS (
    SELECT
        f.title AS film_title,
        l.name AS language_name,
        f.rental_rate
    FROM
        film f
    JOIN
        language l ON f.language_id = l.language_id
)
SELECT
    film_title,
    language_name,
    rental_rate
FROM
    FilmLanguageInfo
ORDER BY
    film_title;
    
-- Q4. CTE for Aggregation
-- Write a query using a CTE to find the total revenue generated by each customer (sum of payments) from 
-- the customer and payment tables
with totalrevenue as
 (
     select
     c.first_name,
     c.last_name ,
     sum(p.amount) as total_revenue
from 
customer c
join payment p on
     p.customer_id = c.customer_id
group by c.first_name, c.last_name)
SELECT 
    fir_name, las_name, total_revenue
FROM
    totalrevenue
ORDER BY total_revenue DESC;

-- Q5. CTE with Window Functions
-- Utilize a CTE with a window function to rank films based on their rental duration from the table
WITH FilmRanking AS (
    SELECT
        film_id,
        title,
        rental_duration,
        RANK() OVER (ORDER BY rental_duration DESC) AS rank1
    FROM
        film
)
SELECT
    film_id,
    title,
    rental_duration,
    rank1
FROM
    FilmRanking
ORDER BY
    rank1;

-- Q6. CTE and Filtering
-- Create a CTE to list customers who have made more than two rentals, and then join this CTE with the
-- customer table to retrieve additional customer details
with customerrentalcount as (
select r.customer_id , 
count(r.rental_id) as rental_count
from rental r 
group by r.customer_id
having count(r.rental_id) >2 
)
SELECT 
    c.customer_id,
    c.first_name,
    c.last_name,
    c.email,
    c.address_id,
    crc.rental_count
FROM
    customerrentalcount crc
        JOIN
    customer c ON c.customer_id = crc.customer_id
ORDER BY crc.rental_count DESC;

-- Q7. CTE for Date Calculations
-- Write a query using a CTE to find the total number of rentals made each month, considering the rental_date
-- from the rental table
with monthlyrental as (
             select extract(month from r.rental_date) as monthly,
                    count(r.rental_id) as rental_count
from  
      rental r
group by
	  extract(month from r.rental_date) 
)
SELECT 
    monthly, rental_count
FROM
    monthlyrental
ORDER BY monthly;

-- Q8. CTE for Pivot Operations
-- Use a CTE to pivot the data from the payment table to display the total payments made by each customer in
-- separate columns for different payment methods
WITH CustomerPayments AS (
    SELECT
        c.customer_id,
        CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
        p.payment_method,
        SUM(p.amount) AS total_amount
    FROM
        customer c
    JOIN
        payment p ON c.customer_id = p.customer_id
    GROUP BY
        c.customer_id, c.first_name, c.last_name, p.payment_method
)
SELECT
    customer_id,
    customer_name,
    COALESCE(SUM(CASE WHEN payment_method = 'Credit Card' THEN total_amount ELSE 0 END), 0) AS Credit_Card,
    COALESCE(SUM(CASE WHEN payment_method = 'Cash' THEN total_amount ELSE 0 END), 0) AS Cash,
    COALESCE(SUM(CASE WHEN payment_method = 'Check' THEN total_amount ELSE 0 END), 0) AS Check1
FROM
    CustomerPayments
GROUP BY
    customer_id, customer_name
ORDER BY
    customer_name;

-- Q9. CTE and Self-Join
-- Create a CTE to generate a report showing pairs of actors who have appeared in the same film together,
-- using the film_actor table
WITH ActorFilms AS (
    SELECT
        fa1.actor_id AS actor_id1,
        fa2.actor_id AS actor_id2,
        fa1.film_id
    FROM
        film_actor fa1
    JOIN
        film_actor fa2 ON fa1.film_id = fa2.film_id
    WHERE
        fa1.actor_id < fa2.actor_id
)
SELECT
    a1.first_name AS actor1_first_name,
    a1.last_name AS actor1_last_name,
    a2.first_name AS actor2_first_name,
    a2.last_name AS actor2_last_name,
    af.film_id
FROM
    ActorFilms af
JOIN
    actor a1 ON af.actor_id1 = a1.actor_id
JOIN
    actor a2 ON af.actor_id2 = a2.actor_id
ORDER BY
    a1.first_name, a1.last_name, a2.first_name, a2.last_name;
    
-- Q10. CTE for Recursive Search
-- Implement a recursive CTE to find all employees in the staff table who report to a specific manager,
-- considering the report_to column.
-- Assuming you want to find all employees who report to a manager with staff_id = 1
WITH RECURSIVE EmployeeHierarchy AS (
    -- Anchor member: Select the manager
    SELECT
        staff_id,
        first_name,
        last_name,
        report_to
    FROM
        staff
    WHERE
        staff_id = 1 
    
    UNION ALL
    
    -- Recursive member: Select employees who report to the manager or to any of the employees found by the previous iteration
    SELECT
        s.staff_id,
        s.first_name,
        s.last_name,
        s.report_to
    FROM
        staff s
    INNER JOIN
        EmployeeHierarchy eh ON s.report_to = eh.staff_id
)
SELECT
    staff_id,
    first_name,
    last_name,
    report_to
FROM
    EmployeeHierarchy
ORDER BY
    report_to, staff_id;
    select * from address;

-- Q1. First Normal Form (1NF)
-- Identify a table in the Sakila database that violates 1NF Explain how you would normalize it to achieve 1NF
/* 
First Normal Form (1NF) requires that each table column contains only atomic (indivisible) values and that each record is unique. 
To identify a table in the Sakila database that might violate 1NF , let's consider the address table.

In the address table, a potential violation could occur if the address or address2 columns are used to store multiple values 
or non-atomic data.For example, if address contains both street name and apartment number in a single field, it violates 1NF.

Steps to Normalize the address Table to 1NF:
To achieve 1NF, ensure that each column contains only atomic values. Hereâ€™s how you can normalize it:

1.Separate Address Components: Split the address column into multiple columns to store
 street name, apartment number, and other details separately.
2. Create a New Table for Additional Addresses: If needed, create a new table for storing additional address details like P.O. Box. */
CREATE TABLE address_normalized (
    address_id INT PRIMARY KEY AUTO_INCREMENT,
    street VARCHAR(255),
    apartment_number VARCHAR(50),
    district VARCHAR(50),
    city_id INT,
    postal_code VARCHAR(10),
    phone VARCHAR(20),
    FOREIGN KEY (city_id) REFERENCES city(city_id)
);

INSERT INTO address_normalized (street, apartment_number, district, city_id, postal_code, phone)
VALUES 
    ('123 Main St', 'Apt 1', 'Manhattan', 1, '10001', '123-456-7890'),
    ('456 Elm St', 'Suite 200', 'Brooklyn', 2, '11201', '987-654-3210'),
    ('789 Oak St', NULL, 'Queens', 3, '11385', '456-789-1234');

-- Q2. Second Normal Form 2NF
-- Choose a table in Sakila and describe how you would determine whether it is in 2NF
-- If it violates 2NF, explain the steps to normalize it

/* 
Second Normal Form (2NF) requires that a table is in First Normal Form (1NF) and
that all non-key attributes are fully functionally dependent on the primary key.
This means there should be no partial dependency of any column on a part of the primary key.

Determine if the Table is in 2NF
To determine if the rental table is in 2NF, we need to:
1.Verify that the table is in 1NF (which it should be if it has atomic columns and a primary key).
2.Ensure that all non-key attributes are fully functionally dependent on the primary key (rental_id).

In the rental table, the primary key is rental_id. We need to check if all non-key columns
(rental_date, inventory_id, customer_id, return_date, staff_id, last_update) are fully functionally dependent on rental_id.

Steps to Normalize to 2NF
1. Identify Partial Dependencies: Identify attributes that are partially dependent on a part of the primary key.
2. Create Separate Tables: Move the partially dependent attributes to a new table where they are fully functionally 
   dependent on a new primary key.
3. Establish Relationships: Maintain foreign key relationships to preserve the original data relationships.
*/

-- Q3. Third Normal Form 3NF
-- Identify a table in Sakila that violates 3NF Describe the transitive dependencies present and outline the
-- steps to normalize the table to 3NF

/* 
Third Normal Form (3NF) requires that a table is in Second Normal Form (2NF) and that all the attributes are directly dependent on the
primary key, i.e.,there should be no transitive dependencies.
 A transitive dependency occurs when a non-key attribute depends on another non-key attribute.
 
 Checking for Transitive Dependencies
In the customer table:
The primary key is customer_id.
The address_id column is a foreign key referring to the
 address table, which contains attributes like address, city_id, and postal_code.
 
 Steps to Normalize to 3NF
1. Identify Transitive Dependencies: Identify attributes that are indirectly dependent on the primary key through another non-key attribute.
2. Create New Tables: Move the transitively dependent attributes to a new table.
3. Establish Foreign Key Relationships: Maintain relationships to preserve the original data structure.

Resulting Structure in 3NF
The customer table is now in 3NF because all non-key attributes are directly dependent on the 
primary key, customer_id. The city and country information is maintained in separate tables and linked through foreign keys.
*/

-- Q4. Normalization Process
-- Take a specific table in Sakila and guide through the process of normalizing it from the initial
-- unnormalized form up to at least 2NF

/*
To guide through the process of normalizing a specific table in the Sakila database from the initial unnormalized form
 up to at least Second Normal Form (2NF), let's take an example of a hypothetical orders table. 
 This example table will illustrate the process clearly, as the Sakila database primarily deals with rentals and customers.

Step 1: Initial Unnormalized Form (UNF)
Let's start with an unnormalized orders table where each order can have multiple products listed in a single column. 
The unnormalized table might look like this:

order_id | customer_id | order_date | products
---------------------------------------------------------------
1        | 100         | 2024-07-10 | 1:2,2:1
2        | 101         | 2024-07-11 | 3:4,4:1
In this example, the products column contains a list of product IDs and quantities in a single string 
(e.g., "1:2,2:1" means product 1 with quantity 2, and product 2 with quantity 1).

Step 2: First Normal Form (1NF)
To achieve 1NF, we need to ensure that each column contains only atomic values and that each row represents a unique entity.
 We will split the products column into separate rows.

order_id | customer_id | order_date | product_id | quantity
----------------------------------------------------------
1        | 100         | 2024-07-10 | 1          | 2
1        | 100         | 2024-07-10 | 2          | 1
2        | 101         | 2024-07-11 | 3          | 4
2        | 101         | 2024-07-11 | 4          | 1
The table is now in 1NF as each cell contains only atomic values.

Step 3: Second Normal Form (2NF)
To achieve 2NF, we need to ensure that the table is in 1NF and that all non-key attributes are fully functionally dependent
 on the primary key. In the orders table, the composite primary key is order_id and product_id.

However, let's assume the product_name is included in the orders table,
 which is only dependent on product_id and not on order_id. This violates 2NF.

order_id | customer_id | order_date | product_id | product_name | quantity
-----------------------------------------------------------------------
1        | 100         | 2024-07-10 | 1          | Widget       | 2
1        | 100         | 2024-07-10 | 2          | Gadget       | 1
2        | 101         | 2024-07-11 | 3          | Doodad       | 4
2        | 101         | 2024-07-11 | 4          | Thingamajig  | 1
To normalize this to 2NF, we need to remove the partial dependency by creating a separate products table.

Steps to Normalize to 2NF
Create the products Table: Move the product_id and product_name attributes to a new products table.

CREATE TABLE products (
    product_id INT PRIMARY KEY,
    product_name VARCHAR(50)
);

INSERT INTO products (product_id, product_name) VALUES
(1, 'Widget'),
(2, 'Gadget'),
(3, 'Doodad'),
(4, 'Thingamajig');
Update the orders Table: Remove the product_name column from the orders table.

CREATE TABLE orders (
    order_id INT,
    customer_id INT,
    order_date DATE,
    product_id INT,
    quantity INT,
    PRIMARY KEY (order_id, product_id),
    FOREIGN KEY (product_id) REFERENCES products(product_id)
);

INSERT INTO orders (order_id, customer_id, order_date, product_id, quantity) VALUES
(1, 100, '2024-07-10', 1, 2),
(1, 100, '2024-07-10', 2, 1),
(2, 101, '2024-07-11', 3, 4),
(2, 101, '2024-07-11', 4, 1);
Resulting Tables in 2NF
products Table

CREATE TABLE products (
    product_id INT PRIMARY KEY,
    product_name VARCHAR(50)
);
orders Table

CREATE TABLE orders (
    order_id INT,
    customer_id INT,
    order_date DATE,
    product_id INT,
    quantity INT,
    PRIMARY KEY (order_id, product_id),
    FOREIGN KEY (product_id) REFERENCES products(product_id)
);
Summary
Initial Unnormalized Form (UNF): The products column had non-atomic values.
First Normal Form (1NF): Split the products column into separate rows.
Second Normal Form (2NF): Removed the product_name column to eliminate partial dependency and created a separate products table.
By following these steps, we have normalized the hypothetical orders table from an unnormalized form to 2NF,
 ensuring that all non-key attributes are fully functionally dependent on the primary key.
 */
 
